module Buildsome.Opts
  ( DeleteUnspecifiedOutputs(..)
  , OverwriteUnregisteredOutputs(..)
  , UpdateGitIgnore(..)
  , Opt(..), Opts(..), get
  ) where

import Control.Monad (liftM)
import Data.ByteString (ByteString)
import Data.List (intercalate)
import Lib.FilePath (FilePath)
import Options.Applicative
import Prelude hiding (FilePath)
import qualified Data.ByteString.Char8 as BS8

data DeleteUnspecifiedOutputs = DeleteUnspecifiedOutputs | DontDeleteUnspecifiedOutputs
data OverwriteUnregisteredOutputs = OverwriteUnregisteredOutputs | DontOverwriteUnregisteredOutputs
data UpdateGitIgnore = UpdateGitIgnore | DontUpdateGitIgnore

data Opt = Opt { optRequestedTargets :: [FilePath]
               , optMakefilePath :: Maybe FilePath
               , optParallelism :: Maybe Int
               , optUpdateGitIgnore :: UpdateGitIgnore
               , optDeleteUnspecifiedOutputs :: DeleteUnspecifiedOutputs
               , optOverwriteUnregisteredOutputs :: OverwriteUnregisteredOutputs
               }

data Opts = GetVersion | Opts Opt

opt :: Read a => Mod OptionFields a -> Parser (Maybe a)
opt = optional . option

strOpt :: Mod OptionFields String -> Parser (Maybe ByteString)
strOpt = (fmap . fmap) BS8.pack . optional . strOption

desc :: String
desc = intercalate "\n"
  [ "Build a buildsome project."
  , ""
  , "Unless -f is given, scans upwards to find a Makefile and "
  , "builds the target named 'default' in the invocation directory."
  , "If 'clean' is used as the sole target name, cleans all "
  , "outputs previously generated by buildsome."
  ]

bytestr :: Monad m => String -> m ByteString
bytestr = liftM BS8.pack . str

get :: IO Opts
get = execParser opts
  where
    parser = versionParser <|> (Opts <$> optsParser)
    versionParser = flag' GetVersion (long "version" <> help "Get buildsome's version")
    optsParser =
      Opt <$> many (argument bytestr (metavar "targets"))
          <*> strOpt (short 'f' <>
                      long "file" <>
                      metavar "file" <>
                      help "Use file as a makefile.")
          <*> opt (short 'j' <>
                   long "parallelism" <>
                   help "How many commands to execute in parallel" <>
                   metavar "jobs")
          <*> ( flag' UpdateGitIgnore
                (short 'g' <>
                 long "gitignore" <>
                 help "Update (or create) .gitignore file in the same directory as the Makefile (default)")
                <|>
                flag' DontUpdateGitIgnore
                (short 'G' <>
                 long "no-gitignore" <>
                 help "Do not touch the .gitignore file in the same directory as the Makefile")
                <|>
                pure UpdateGitIgnore
              )
          <*> (flag DontDeleteUnspecifiedOutputs DeleteUnspecifiedOutputs
               (short 'D' <>
                long "delete-unspecified" <>
                help "Delete unspecified outputs"))
          <*> (flag DontOverwriteUnregisteredOutputs OverwriteUnregisteredOutputs
               (long "overwrite" <>
                help "Overwrite outputs not created by buildsome"))
    opts = info (helper <*> parser) (fullDesc <> progDesc desc <> header "buildsome - build an awesome project")
