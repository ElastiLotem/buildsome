module Opts
  ( DeleteUnspecifiedOutputs(..)
  , OverwriteUnregisteredOutputs(..)
  , Opt(..), getOpt
  ) where

import Data.List (intercalate)
import Options.Applicative

data DeleteUnspecifiedOutputs = DeleteUnspecifiedOutputs | DontDeleteUnspecifiedOutputs
deleteUnspecifiedOutputs :: Bool -> DeleteUnspecifiedOutputs
deleteUnspecifiedOutputs False = DontDeleteUnspecifiedOutputs
deleteUnspecifiedOutputs True = DeleteUnspecifiedOutputs

data OverwriteUnregisteredOutputs = OverwriteUnregisteredOutputs | DontOverwriteUnregisteredOutputs
overwriteUnregisteredOutputs :: Bool -> OverwriteUnregisteredOutputs
overwriteUnregisteredOutputs False = DontOverwriteUnregisteredOutputs
overwriteUnregisteredOutputs True = OverwriteUnregisteredOutputs

data Opt = Opt { optRequestedTargets :: [FilePath]
               , optMakefilePath :: Maybe FilePath
               , optParallelism :: Maybe Int
               , optGitIgnore :: Bool
               , optDeleteUnspecifiedOutputs :: DeleteUnspecifiedOutputs
               , optOverwriteUnregisteredOutputs :: OverwriteUnregisteredOutputs
               }

opt :: Read a => Mod OptionFields a -> Parser (Maybe a)
opt = optional . option

strOpt :: Mod OptionFields String -> Parser (Maybe String)
strOpt = optional . strOption

desc :: String
desc = intercalate "\n"
  [ "Build a buildsome project."
  , ""
  , "Unless -f is given, scans upwards to find a Makefile and "
  , "builds the target named 'default' in the invocation directory."
  , "If 'clean' is used as the sole target name, cleans all "
  , "outputs previously generated by buildsome."
  ]

getOpt :: IO Opt
getOpt = execParser opts
  where
    parser = Opt <$> many (argument str (metavar "targets"))
                 <*> strOpt (short 'f' <>
                             long "file" <>
                             metavar "file" <>
                             help "Use file as a makefile.")
                 <*> opt (short 'j' <>
                          long "parallelism" <>
                          help "How many commands to execute in parallel" <>
                          metavar "jobs")
                 <*> switch (short 'g' <>
                             long "gitignore" <>
                             metavar "path" <>
                             help "Write a .gitignore file in the same directory as the Makefile")
                 <*> (deleteUnspecifiedOutputs <$>
                      switch (short 'D' <>
                              long "delete-unspecified" <>
                              help "Delete unspecified outputs"))
                 <*> (overwriteUnregisteredOutputs <$>
                      switch (long "overwrite" <>
                              help "Overwrite outputs not created by buildsome"))
    opts = info (helper <*> parser) (fullDesc <> progDesc desc <> header "buildsome - build an awesome project")
